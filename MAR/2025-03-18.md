# TIL Template

## 날짜: 2025-03-18

### 스크럼
- 학습 목표 : 능동적으로 공부하기

### 개념 정리

|  | 정의 | 비고 |
| --- | --- | --- |
| JPA(Java Persistence API) | Java 플랫폼을 위한 ORM 기술 표준 | @GeneratedValue 어노테이션은 이름 자체로 어떤 값을 생성한다는 것을 암시하며, 일반적으로 @Id 어노테이션과 함께 사용되어 데이터베이스 테이블의 기본 키 컬럼에 대한 고유 값을 자동으로 생성한다.<br><br>엔티티 클래스를 생성할 때 해당 엔티티의 기본 키를 지정해야 하는데, 이때 필드나 프로퍼티를 기본 키로 표시하기 위해 @Id 어노테이션을 사용한다. 그리고 기본 키 필드나 프로퍼티에 @GeneratedValue 어노테이션을 적용하면, 엔티티를 데이터베이스에 영속화하는 과정에서 Hibernate가 해당 필드에 대한 고유 값을 자동으로 생성하도록 지시한다.<br><br><br>@GeneratedValue의 pk 생성 전략은 다음과 같다.<br><br>GenerationType.AUTO: 기본 전략으로, 영속성 제공자가 데이터베이스 사용에 따라 적절한 기본 키 생성 전략을 자동으로 선택한다.<br><br>GenerationType.IDENTITY: 데이터베이스의 auto-increment 컬럼 옵션을 사용하여 기본 키 값을 데이터베이스 자체에서 생성하도록 돕는다. 데이터베이스가 고유 값을 생성할 수 있는 네이티브 기능에 의존한다.<br><br>GenerationType.TABLE: 별도의 데이터베이스 테이블을 사용하여 기본 키 값을 생성한다. 영속성 제공자가 이 테이블을 관리하며, 이를 통해 기본 키에 대해 고유한 값을 할당한다.<br><br>GenerationType.SEQUENCE: 이 전략은 데이터베이스 시퀀스를 사용하여 기본 키 값을 생성한다. 사용 중인 데이터베이스에 따라 달라지는 데이터베이스 시퀀스 객체의 사용이 필요하다.<br><br><br>JPA 2.1 이전에 Enum 값을 데이터베이스 표현으로 매핑하는 가장 일반적인 방법으로 @Enumerated 어노테이션을 사용했다.<br><br>Enum 필드에 @Enumerated(EnumType.ORDINAL) 어노테이션을 적용하면, JPA는 해당 엔티티를 데이터베이스에 영속화할 때 Enum.ordinal() 값을 사용한다.<br>이 방식은 Enum의 순서를 변경하거나 중간에 새로운 값을 추가하면 기존 데이터 모델을 깨뜨릴 위험이 있다. 이러한 문제는 발견하기도 어렵고, 수정하기도 어려워 모든 데이터베이스 레코드를 업데이트해야 할 수 있기 때문에 사용을 지양한다.<br><br>Enum 필드에 @Enumerated(EnumType.STRING) 어노테이션을 적용하면, JPA는 해당 엔티티를 영속화할 때 Enum.name() 값을 사용한다.<br>@Enumerated(EnumType.STRING)을 사용하면 새로운 Enum 값을 안전하게 추가하거나 Enum의 순서를 변경해도 기존 데이터 모델에 영향을 주지 않는다. 다만, Enum 값을 이름(String)으로 저장하므로 공간을 더 많이 차지할 수 있기 때문에 대량의 데이터를 처리해야 하는 경우 문제가 될 수 있다.<br><br>또 다른 방법은 표준 JPA 콜백 메서드를 이용하는 것이다. 이를 통해 @PostLoad와 @PrePersist 이벤트에서 Enum을 데이터베이스 값과 상호 변환(mapping)할 수 있다.<br>이 옵션은 Enum의 데이터베이스 표현 방식을 더 유연하게 선택할 수 있게 해주지만, 한 엔티티에 두 개의 속성이 존재하므로 깔끔하지 않고, JPQL 쿼리에서 Enum 값을 직접 사용할 수 없다는 단점이 있다.<br><br>위 옵션들의 한계를 극복하기 위해 JPA 2.1에서는 엔티티 속성을 데이터베이스 값으로, 그리고 그 반대로 변환할 수 있는 표준 API인 AttributeConverter를 도입했다. 이 방식은 새로운 클래스를 작성하여 AttributeConverter 인터페이스를 구현하고, @Converter 어노테이션을 붙이면 된다.<br>AttributeConverter 인터페이스를 사용하면 Enum과 데이터베이스 값 간의 변환 규칙을 직접 정의할 수 있으며, 기존에 제시된 옵션들의 단점을 모두 해소할 수 있다.<br><br><br>@Embeddable 및 @Embedded 어노테이션은 객체의 프로퍼티를 데이터베이스 테이블의 컬럼에 매핑하는 데 사용된다. 이 어노테이션들은 함께 사용되어 한 클래스의 프로퍼티를 다른 클래스에 값 타입으로 포함시켜, 포함하는 클래스의 일부로서 데이터베이스에 영속화할 수 있도록 한다.<br><br>@Embeddable: 클래스를 embeddable로 표시하여 해당 클래스의 프로퍼티들이 다른 클래스에 값 타입으로 포함될 수 있음을 나타낸다. @Embeddable이 붙은 클래스는 임베디드 클래스라고 한다.<br><br>@Embedded: 한 클래스 내의 필드를 임베디드 객체로 표시하는 데 사용되며, 임베디드 객체를 포함하는 클래스에서 사용된다.<br><br><br>공통 매핑 정보를 상속받는 클래스에 제공할 때 @MappedSuperclass를 사용한다.<br><br>@MappedSuperclass는 클래스를 슈퍼클래스로 표시하며, 특정 데이터베이스 테이블과 연관되지 않지만 그 필드가 테이블과 연관된 자식 엔티티 클래스에 상속될 수 있음을 나타낸다.<br>이를 통해 코드 중복을 방지하고 보다 깔끔한 객체 모델 구조를 보장할 수 있다. |
| 엔티티 매니저(Entity Manager) | 영속성 컨텍스트와 상호 작용하기 위해 사용되는 인터페이스 | EntityManager API는 영속 엔티티 인스턴스의 생성 및 제거, 기본 키를 통한 엔티티 조회, 그리고 엔티티에 대한 쿼리 실행에 사용된다.<br><br>생성은 EntityManagerFactory에서 이뤄지며, 보통 요청/스레드 단위로 사용 후 반환된다.<br><br>Spring에서는 트랜잭션 단위로 관리되며, 스프링 부트+Spring Data JPA 환경에서는 EntityManager를 직접 쓰지 않고, Repository(예: JpaRepository)를 통해 내부적으로 사용된다. |
| 영속성 컨텍스트(Persistence Context) | 모든 영속 엔티티 식별자에 대해 고유한 엔티티 인스턴스가 존재하는 엔티티 인스턴스들의 집합 | 엔티티들은 영속성 컨텍스트 내에서 관리되며, EntityManager가 라이프사이클을 제어하고, 데이터 저장소 자원에 접근할 수 있게 한다.<br><br>영속성 컨텍스트는 모든 엔티티가 데이터베이스로부터 조회되거나 데이터베이스에 저장되는 “1차 캐시” 역할을 한다.<br><br>동일 트랜잭션 안에서 같은 PK 엔티티를 재조회 시 SELECT 쿼리 추가 실행되지 않기 때문에 동일성이 보장된다.<br><br><br>영속성 컨텍스트는 관리되는 엔티티에 발생한 모든 변경 사항을 추적한다. 트랜잭션 동안 엔티티에 어떤 변화가 발생하면, 해당 엔티티는 "더티(dirty)" 상태로 표시되며, 트랜잭션이 완료되면 이러한 변경 사항들이 영속 저장소에 플러시된다.<br><br><br>Session per request 패턴은 영속성 세션과 요청의 생명주기를 연결하는 트랜잭션 패턴으로, Spring은 이 패턴의 자체 구현체인 OpenSessionInViewInterceptor(OSIV)를 제공하여 Lazy 연관관계를 다루기 쉽게 하여 개발 생산성을 향상시킨다.<br><br>OSIV가 없다면, 모든 필요한 Lazy 연관관계를 트랜잭션 컨텍스트 내에서 수동으로 초기화해야 할 것이다.<br><br><br>OSIV가 활성화되어 있으면, 활성 트랜잭션이 없더라도 현재 요청 범위 내에는 항상 Session이 존재한다. <br><br>처음에는 연결되지 않더라도, 첫 데이터베이스 IO 이후 연결되어 요청 종료 시까지 유지되기 때문에 데이터베이스 커넥션 풀이 고갈될 수 있다.<br><br>요청 생명주기 동안 Session이 열려 있기 때문에, 일부 프로퍼티 탐색은 트랜잭션 컨텍스트 외부에서 원치 않는 추가 쿼리를 발생시킬 수 있으며, N+1 SELECT 문제를 초래할 수도 있다.<br><br>이러한 추가 쿼리들은 모두 자동 커밋 모드에서 실행된다. 자동 커밋 모드에서는 각 SQL 문이 개별 트랜잭션으로 처리되고 실행 직후 자동으로 커밋되므로, 데이터베이스에 많은 부담을 준다.<br><br><br>단순한 CRUD 서비스 개발 중이라면 OSIV를 사용하는 것이 타당할 수 있지만, 많은 원격 서비스를 호출하거나 트랜잭션 컨텍스트 외부에서 많은 작업이 발생하는 경우라면 OSIV를 완전히 비활성화하는 것이 강력히 권장된다.<br><br>OSIV를 비활성화할 경우, Lazy 연관관계 처리에 따른 LazyInitializationException을 방지하기 위해 엔티티 그래프(@EntityGraph)나 Fetch Join을 사용하는 것이 좋다.<br><br><br>Hibernate는 영속성 컨텍스트에 연관된 객체들이 INSERT, UPDATE, DELETE 쿼리 등으로 인해 수정되면 변경 사항이 즉시 데이터베이스에 전파되지 않고, 트랜잭션과 연관된 모든 데이터베이스 작업을 수집하여 최소한의 SQL 쿼리 집합을 생성한 후 이를 실행한다.<br><br>이로 인해 엔티티의 각 프로퍼티 변경이 별도의 SQL UPDATE 실행을 유발하지 않으며, 불필요한 SQL 쿼리 실행을 방지하여 데이터베이스로의 네트워크 왕복 횟수를 최소화, 네트워크 지연 시간을 줄일 수 있다.<br><br>SQL 쿼리의 이러한 지연 실행은 "transactional write behind"라고 불리며, 트랜잭션의 commit()이 호출되면 Hibernate는 모든 SQL을 데이터베이스에 플러시한다. |
| 엔티티 생명주기 | 엔티티 생명주기는 영속성 컨텍스트 동작에 따라 비영속 → 영속 → 준영속 → 삭제로 이동한다. | 비영속(Transient) 엔티티: 데이터베이스에 대응하는 표현이 없고 어떤 Session에도 의해 관리되지 않는 엔티티 객체로, 단순히 "new"로 객체만 만든 상태이다.<br><br>영속(Managed) 엔티티: 데이터베이스 테이블의 한 행을 나타내는 엔티티로, 아직 데이터베이스에 존재하지 않을 수도 있다.<br>영속 컨텍스트에 등록된 상태로, 1차 캐시, 변경 감지, 지연 로딩 등이 적용된다.<br><br>준영속(Detached) 엔티티: 단순한 POJO(Plain Old Java Object)로서, 그 식별자 값이 데이터베이스의 행과 일치하는 경우이다.<br>한때 영속이었으나, 트랜잭션 종료 등으로 인해 영속성 컨텍스트에서 분리된 상태로, 더 이상 변경 감지, 지연 로딩 등이 적용되지 않는다.<br><br>삭제된(Removed) 엔티티: Session.delete(entity)가 호출되어 엔티티가 삭제 상태로 표시되면, 해당 엔티티는 삭제(removed) 상태가 된다.<br>DELETE 명령은 단위 작업이 끝날 때 실행될 수 있다. |
| Spring Data JPA | JPA에 대한 추상화 계층을 제공하여 스프링부트 애플리케이션에서 데이터베이스 접근을 단순화하는 프레임워크 | Spring Data JPA는 Spring 프레임워크의 일부로, 다양한 영속 저장소에 대한 데이터 접근 계층을 구현할 때 필요한 보일러플레이트 코드를 크게 줄여주는 것을 목표로 하는 리포지토리 추상화를 제공한다.<br><br>객체-관계 매핑(ORM)을 사용해 관계형 데이터베이스와 원활하게 통합되며, 불필요한 SQL 쿼리 코드를 제거해준다.<br><br>자동 쿼리 생성, JPQL 지원, 그리고 손쉬운 리포지토리 관리를 비롯한 기능들을 통해 개발 효율성을 높인다. |
| 지연 로딩(Lazy Loading) | 데이터가 필요할 때만 로드되도록 하는 기법으로, 관련 또는 연관 데이터의 가져오기를 명시적으로 요청될 때까지 미루는 것이다. | 필요한 데이터만 로드되어 애플리케이션의 시작 성능이 향상되며, 대용량 데이터셋에 최적이다.<br><br>지연된 데이터 로딩을 처리하기 위해 복잡한 로직이 필요하며, 여러 번의 데이터베이스 호출이 발생하여 전체 요청 횟수가 증가할 수 있다. |
| 즉시 로딩(Eager Loading) | 관련 데이터를 포함한 모든 필요한 데이터를 하나의 요청에 미리 로드하여 필요한 모든 정보에 즉시 접근할 수 있도록 하는 전략 | 모든 필요한 데이터가 미리 로드되어 연관 데이터 접근 시 지연이 없으며, 한 번에 모든 데이터를 가져와 데이터베이스 쿼리 수를 줄일 수 있다.<br>모든 데이터가 즉시 사용 가능하므로, 나중에 연관 데이터를 로드하기 위한 복잡한 로직이 필요 없다.<br><br>모든 데이터를 한 번에 로드하므로 애플리케이션 시작 또는 페이지 로드 시간이 느려질 수 있으며, 메모리 사용량이 많아질 수 있다. |

### 오늘의 회고
온라인 기간이 끝나고 오프라인으로 진행된 첫 번째 수업이었다. 스프링에 대해 공부하면서 항상 느끼는 점인데, 알면 알수록 모르는 것이 많아지는 기분이다. 특히 아무 생각 없이 사용해왔던 OSIV 관련 내용은 다시 한번 프레임워크의 소중함을 일깨워 줬다. 아는데 안 쓰는 것과 몰라서 못 쓰는 것은 정말 큰 차이라고 생각하기 때문에 앞으로도 계속 더 깊게 공부해 보고 싶다는 생각이 들었다.

### 참고 자료 및 링크
- [JPA - Introduction - GeeksforGeeks](https://www.geeksforgeeks.org/jpa-introduction/)
- [Hibernate - @GeneratedValue Annotation in JPA - GeeksforGeeks](https://www.geeksforgeeks.org/hibernate-generatedvalue-annotation-in-jpa/?ref=header_outind)
- [Persisting Enums in JPA - Baeldung](https://www.baeldung.com/jpa-persisting-enums-in-jpa)
- [Hibernate - @Embeddable and @Embedded Annotation - GeeksforGeeks](https://www.geeksforgeeks.org/hibernate-embeddable-and-embedded-annotation/)
- [Jpa @Embedded and @Embeddable - Baeldung](https://www.baeldung.com/jpa-embedded-embeddable)
- [Hibernate @MappedSuperclass for Inheritance - Medium](https://medium.com/jpa-java-persistence-api-guide/hibernate-mappedsuperclass-for-inheritance-b65a753eb5a5)
- [EntityManager - Java EE 6](https://docs.oracle.com/javaee/6/api/javax/persistence/EntityManager.html)
- [Persistence Context - Oracle](https://docs.oracle.com/html/E13946_01/ejb3_overview_emfactory_perscontext.html)
- [JPA/Hibernate Persistence Context - Baeldung](https://www.baeldung.com/jpa-hibernate-persistence-context)
- [A Guide to Spring's Open Session In View - Baeldung](https://www.baeldung.com/spring-open-session-in-view)
- [Write-Behind Technique In Hibernate - Blogger.com](http://learningviacode.blogspot.com/2012/02/write-behind-technique-in-hibernate.html)
- [Hibernate Entity Lifecycle - Baeldung](https://www.baeldung.com/hibernate-entity-lifecycle)
- [Spring Data JPA - docs.spring.io](https://spring.io/projects/spring-data-jpa)
- [Spring Boot - Spring Data JPA - GeeksforGeeks](https://www.geeksforgeeks.org/spring-boot-spring-data-jpa/)
- [What is Spring Data JPA? - GeeksforGeeks](https://www.geeksforgeeks.org/what-is-spring-data-jpa/)
- [Lazy Loading vs. Eager Loading - GeeksforGeeks](https://www.geeksforgeeks.org/lazy-loading-vs-eager-loading/?ref=header_outind)
