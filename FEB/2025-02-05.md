# TIL Template

## 날짜: 2025-02-05

### 스크럼
- 학습 목표 : 능동적으로 공부하기

### 개념 정리

|  | 정의 | 비고 |
| --- | --- | --- |
| 동기 | 함수 호출 시 결과가 반환될 때까지 기다리는 처리 방식 | 특정 작업이 완료 될 때까지 기다리는 방식으로, 제어권은 특정 작업 실행 이후에 돌려 받는다. |
| 비동기 | 함수 호출과 결과 반환 사이에 다른 작업을 수행할 수 있는 처리 방식 | 특정 작업에 대한 진행 상황, 결과 처리를 제어권이 신경 쓰지 않으며, 비동기 직업 이후 결과 처리를 해야 한다면 기존에 진행하고 있는 작업이 있다면 처리후 진행한다. |
| 블로킹 | 현재 실행 중인 작업이 완료될 때까지 다음 작업을 기다리는 방식 | 해당 작업이 완료되기 전까지는 다른 어떤 작업도 수행할 수 없다. |
| 논블로킹 | 현재 실핼 중인 작업의 완료를 기다리지 않고 다음 작업을 실행하는 방식 | 해당 작업의 완료 여부와 상관없이 프로그램이 계속해서 실행될 수 있다. |

### 동기 / 비동기의 차이를 설명(파일 읽기 작업을 예시로)

- 동기
    - 요청한 파일 읽기 작업이 완료될 때까지 다음 작업을 진행하지 않고 기다린다.
        
        ```jsx
        const fs = require('fs');
        
        console.log('작업 시작');
        
        const data = fs.readFileSync('./file_path');
        conssole.log('파일 읽기 완료: ', data);
        
        console.log('다음 작업');
        ```
        
        ```jsx
        작업 시작
        파일 읽기 완료: Hello, world!
        다음 작업
        ```
        
- 비동기
    - 요청한 파일 읽기 작업이 완료될 때까지 기다리지 않고 다음 작업을 수행하며, 결과가 준비되면 처리한다.
        
        ```jsx
        const fs = require("fs");
        
        console.log('작업 시작');
        
        fs.readFile('./file_path', (err, datta) => {
            if (err) return err;
            console.log('파일 읽기 완료: ', data);
        });
        
        console.log('다음 작업');
        ```
        
        ```jsx
        작업 시작
        다음 작업
        파일 읽기 완료: Hello, world!
        ```
        

### 블로킹, 논블로킹(제어권 관점)

- 블로킹
    - 특정 작업 실행시 제어권을 완전히 넘기는 방식으로, 제어권이 넘어 갔기 때문에 다른 작업을 진행할 수 없다.
- 논블로킹
    - 특정 작업 실행시 제어권을 넘겨 실행 후 즉시 돌려 받는 방식으로, 제어권을 돌려 받기 때문에 다른 작업을 진행(작업이 진행되는 동안 백그라운드에서 다른 작업이 진행)할 수 있다.

### 동기 + 블로킹, 동기 + 논블로킹 조합의 차이

- 동기 + 블로킹
    - 함수를 호출하면 제어권이 호출된 함수로 넘어가고, 해당 함수가 완전히 끝날 때까지 호출한 곳은 대기한다.
        - 즉, 현재 스레드는 함수가 끝날 때까지 멈춘다.
- 동기 + 논블로킹
    - 함수를 호출하면 제어권은 호출된 함수로 넘어갔다가 바로 호출한 곳으로 돌아오지만, 함수를 실행하는 동안 호출한 곳에서는 결과가 완료될 때까지 결과처리에 대해서 지속적인 관찰(Polling)을 해야 한다.
        - 즉, 함수가 끝날 때까지 기다리지는 않지만, 여전히 동기적 흐름을 유지하며, 완전히 비동기적이지 않다.

### 비동기 I/O, 논블로킹 I/O의 차이

- 논블로킹 I/O(Non-blocking I/O)
    - I/O 요청 후 제어권이 즉시 반환되지만, I/O 작업의 결과를 반복해서 확인(Polling)해야 한다.
- 비동기 I/O(Asynchronous I/O)
    - I/O 요청 후 제어권이 즉시 반환되는건 동일하지만, I/O가 완료되면 OS가 자동으로 프로세스에 알려준다.

### (선택) 멀티 스레드 환경에서 블로킹 I/O를 사용할때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법

블로킹 I/O는 I/O 작업(예: 파일 읽기, 네트워크 요청)을 요청할 때 해당 작업이 완료될 때까지 프로그램의 실행을 멈추는 방식이다.

멀티 스레드 환경에서는 여러 스레드가 동시에 실행되기 때문에 스레드 간의 컨텍스트 스위칭이 빈번하게 발생하는데, 블로킹 I/O를 사용한 스레드는 대기 상태로 전환되며, 다른 스레드가 실행되기 위해 컨텍스트 스위칭(Context Switching)이 발생한다.

컨텍스트 스위칭의 오버헤드를 최소화하고 멀티스레딩의 이점을 극대화하기 위해 개별 스레드를 직접 생성하는 대신 스레드 풀을 사용하여 스레드의 생성과 소멸 비용을 줄여 오버헤드를 줄일 수 있다

### (선택) 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점

웹 서버 아키텍처에서 블로킹 방식을 사용한다면 서버가 클라이언트의 요청을 처리할 때 다른 요청들은 I/O가 완료될 때까지 기다리게 되고, 이는 서버의 응답 속도가 느려지는 원인이 된다.

반면 논블로킹 방식을 사용한다면 즉시 제어권을 돌려받고 다른 요청을 처리하면서 I/O 작업을 백그라운드에서 처리할 수 있게 되고, 이로 인해 서버의 응답 속도는 빨라지게 된다.

### 오늘의 회고
자바에 대한 내용이 아닌 더 낮은 레벨의 개념들이 나오다 보니 공식 문서 찾는 게 좀 힘들어서 오래 걸렸다. 자료 검색이 익숙해지고, 지금까지 배운 내용을 주변 사람들에게 설명할 수 있게 되는 그날까지..

### 참고 자료 및 링크
- [동기와 비동기, 블로킹과 논블로킹의 차이점](https://f-lab.kr/insight/understanding-sync-async-blocking-nonblocking)
- [Operating System Concepts, 10/E](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf)
- [Chapter 12: I/O Systems](https://www.andrew.cmu.edu/course/14-712-s20/applications/ln/14712-l15.pdf)
- [비동기 I/O](https://www.ibm.com/docs/ko/i/7.3?topic=concepts-asynchronous-io)
- [블로킹과 넌블로킹 I/O의 이해와 실제 적용 사례](https://f-lab.kr/insight/understanding-blocking-and-non-blocking-io)
- [컨텍스트 스위칭과 멀티스레딩의 이해](https://f-lab.kr/insight/understanding-context-switching-and-multithreading)
