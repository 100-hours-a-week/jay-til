# TIL Template

## 날짜: 2025-02-10

### 스크럼
- 학습 목표 : 능동적으로 공부하기

### 개념 정리

|  | 정의 | 비고 |
| --- | --- | --- |
| 공유 자원(Shared Resource) | 여러 작업(프로세스/스레드)이 동시에 접근하고 사용할 수 있는 자원 | 자원을 독점적으로 사용하면 시스템 리소스가 낭비될 가능성이 높기 때문에 공유 자원을 통해 여러 사용자나 프로세스가 동일한 자원을 활용하여 시스템 효율성을 향상시킬 수 있다. |
| 임계 영역(Critical Section) | 공유 자원에 접근하는 프로그램 코드의 일부분 | 공유 자원 자체는 여러 프로세스나 스레드가 접근할 수 있는 대상(데이터, 파일, 메모리 등)을 의미하지만, 임계 영역은 공유 자원을 사용하려는 프로그램 내부의 코드 중에서도 충돌이 발생할 가능성이 있는 부분이다. |
| 동기화(Synchronization) | 여러 작업(프로세스/스레드)이 공유 자원에 동시에 접근할 때 발생할 수 있는 문제들을 방지하기 위해 올바른 순서 조정을 보장하는 메커니즘 | 동기화가 제대로 되지 않으면 데이터 무결성 손실, 데이터 경합, 데드락 등의 문제가 발생하여 안전한 소프트웨어를 설계하기 어렵고, 이러한 문제는 시스템 안정성과 신뢰성을 심각하게 훼손할 수 있다. |
| 락(Lock) | 하나의 작업(프로세스/스레드)이 자원을 점유할 경우 다른 작업이 해당 자원에 접근하지 못하도록 제어하는 기법 | 락이 다른 스레드의 작업 간섭을 방지하여 특정 작업 단위(critical section)가 중단 없이 완전하게 실행될 수 있도록 보장하기 때문에 원자성을 보장한다. |
| 원자성(Atomicity) | 작업 단위가 더 이상 나뉠 수 없는 하나의 원자적 실행 단위로 동작함을 보장하는 개념 | 즉, 작업이 모두 실행되거나, 전혀 실행되지 않는 상태를 의미하며, 중간에 중단되거나 일부만 실행되는 일이 없다. |
| 상호 배제(Mutual Exclusion) | 2개 이상의 스레드(또는 프로세스)이 동시에 공유자원에 접근하지 못하도록 한다. | 다른 스레드가 동시에 같은 자원을 변경할 수 없도록 보장 |
| 진행(Progress) | 공유 자원에 접근 중인 스레드가 없고, 대기 중인 작업이 있다면 대기 중인 스레드 중 하나는 반드시 임계 영역에 들어가 실행되어야 한다. | 경쟁 프로세스가 없을 때, 즉시 실행이 가능해야 한다. |
| 유한한 대기(Bounded Waiting) | 어떤 스레드도 다른 스레드에 의해 무한히 대기 상태로 남겨져서는 안 된다. | 대기 중인 프로세스가 영구적으로 차단되지 않도록 한다. |
| 데드락(Deadlock) | 두 개 이상의 작업(스레드)이 서로가 소유한 자원을 영원히 대기하는 상태 | Coffman 조건은 데드락 발생의 4가지 필요 조건으로, 4가지 조건이 모두 만족될 때 데드락이 발생한다. |
| 데이터 경합(Race Condition) | 여러 작업(프로세스/스레드)이 동시에 같은 데이터에 접근해서 수정할 때 실행 결과가 순서에 따라 달라지는 상황 | 복합 연산(예: 증가 연산, i++)을 volatile 변수로 수행할 경우 원자성이 보장되지 않아 race condition이 발생할 수 있다. |
| (선택) 기아 현상(Starvation) | 우선순위가 높은 작업을 우선적으로 처리하려다 우선순위가 낮은 작업을 영원히 처리하지 못하는 현상 | 스케쥴러가 우선순위 기반(Priority-Based) 알고리즘을 사용할 경우에 발생할 수 있다. |
| (선택) 락-프리(Lock-Free) | 락 없이 동기화를 구현해 전체 시스템에서 최소 한 스레드가 진행되도록 보장하는 알고리즘 | 하드웨어의 원자적 연산(compare-and-swap 등)을 사용하여 여러 스레드가 동시에 작업을 수행할 때 적어도 한 스레드는 유한한 단계 내에 작업을 완료할 수 있도록 보장한다. |
| (선택) 웨이트-프리(Wait-Free) | 락 없이 동기화를 구현하면서, 모든 스레드가 유한한 단계 내에 반드시 자신의 연산을 완료하도록 보장하는 알고리즘 | lock-free 알고리즘은 전체 시스템에서 적어도 한 스레드가 진행됨을 보장하는 반면, wait-free 알고리즘은 모든 스레드가 진행됨을 보장한다. |
| 스핀락 | 스레드가 락이 해제되기를 기다리며 계속해서 반복적으로 락 상태를 확인하는 방식의 락 | 스핀락은 락을 점유하지 못한 스레드가 락 상태를 반복적으로 확인하며 대기하는 busy-waiting 방식을 사용한다.<br>락 대기 중 컨텍스트 스위칭(스레드 스케줄링)이 발생하지 않으므로 락이 짧은 시간 내에 해제될 경우 오버헤드가 적지만, 락 해제가 오래 걸릴 경우 busy-waiting으로 인한 비효율이 발생하며, 다른 프로세스/스레드의 CPU 자원 사용을 방해할 수 있다. |
| 낙관적 락 | 락 없이 작업을 수행하고, 충돌이 발생하면 롤백을 통해 해결하는 방식의 락 | 락 없이 자원에 접근을 시도하며, 자원 충돌(경합)이 발생하지 않을 것이라고 가정한다.<br>작업 완료 후 자원 충돌 여부를 검증하며, 충돌이 발생하면 작업을 되돌리고 다시 시도한다. |
| 뮤텍스(Mutex) | 한 번에 하나의 작업(프로세스/스레드)만 공유 자원에 접근하도록 보장하는 락 | Binary semaphore(the value can range only between 0 and 1)와 유사하게 동작한다. |
| 조건 변수(Condition Variable) | 스레드가 특정 조건이 충족될 때까지 대기하거나, 다른 스레드가 신호(Signal)를 보내 대기 중인 스레드를 깨워 실행을 재개하도록 하는 동기화 기법 | 조건 변수에서 호출할 수 있는 유일한 작업은 wait() 및 signal()뿐이다. |
| Read-Write Lock | 다중 스레드 환경에서 읽기(Reader) 작업과 쓰기(Writer) 작업을 구분하여 락을 관리하는 동기화 기법 | 여러 Reader는 동시에 자원에 접근할 수 있지만, Writer는 자원을 독점적으로 사용해야 한다.<br>많은 Reader가 연속적으로 자원을 점유할 경우, Writer가 락을 획득하지 못해 대기 시간이 길어질 수 있는 Writer 기아 현상이 발생할 수 있다. |
| 세마포어(Semaphore) | 정해진 수의 스레드만 공유 자원에 접근할 수 있도록 제한하는 동기화 기법 | wait() 및 signal() 연산에서 세마포어의 정수 값에 대한 모든 수정은 원자적으로 실행되어야 한다. |
| (선택) 분산 락(Distributed Lock) | 분산 시스템 환경에서 임계 구역의 상호 배제를 보장하는 락 | 중앙 집중식 시스템이나 분산 캐시 및 합의 알고리즘 등을 활용하여 구현한다. |

### 공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.

공유 자원이란 여러 작업(프로세스/스레드)이 동시에 접근하고 사용할 수 있는 자원으로, 시스템에서 공유 자원을 사용해야 하는 이유는 다음과 같다.

1. 리소스 낭비 방지
    - 공유 자원을 통해 여러 사용자나 프로세스가 동일한 자원을 활용하여 시스템 효율성을 향상시킬 수 있다.
        - ex) 회사에서 모든 직원이 각각 개인용 복사기를 갖는다면, 복사기 구매비용뿐 아니라 사용하지 않는 시간 동안에도 불필요한 전력 소비 등 리소스가 낭비된다. 대신 한 대의 공용 복사기를 사용하면 여러 직원이 필요할 때마다 공유하여 사용하므로, 비용과 에너지 면에서 효율적이다.
2. 협업 가능성 증대
    - 데이터를 공유함으로써 여러 사용자가 동시에 협력 작업을 수행할 수 있다.
        - ex) 공용 복사기를 사용하면, 직원들이 서로 같은 복사본을 쉽게 얻을 수 있고, 회의 자료나 공동 프로젝트 자료를 복사해 공유할 수 있어 협업이 용이해진다.

### 임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?

임계 영역이란 공유 자원에 접근하는 프로그램 코드의 일부분으로, 임계 영역을 보호하지 않을 경우 데이터 무결성이 보장되지 않으며, 경합 조건(Race Condition)이 발생할 수 있다. 이로 인해 의도하지 않은 예측 불가능한 결과가 발생할 수 있기 때문에 시스템 안정성과 신뢰성을 심각하게 훼손할 수 있다.

임계 영역 문제에 대한 근본적인 해결책은 상호 배제(Mutual Exclusion)를 통해 공유자원에 대한 동시접근을 방지하는 것이다. 하지만 상호배제에 집중하다 보면 기아 현상(Starvation)이 발생할 수 있는데, 이를 방지하기 위해 다음의 진행(Progress)과 유한한 대기(Bounded Waiting)이라는 조건을 추가하여야 한다.

- 상호 배제(Mutual Exclusion)
    - 2개 이상의 스레드(또는 프로세스)이 동시에 공유자원에 접근하지 못하도록 한다.
- 진행(Progress)
    - 공유 자원에 접근 중인 스레드가 없고, 대기 중인 작업이 있다면 대기 중인 스레드 중 하나는 반드시 임계 영역에 들어가 실행되어야 한다.
- 유한한 대기(Bounded Waiting)
    - 어떤 스레드도 다른 스레드에 의해 무한히 대기 상태로 남겨져서는 안 된다.

### 동기화 메커니즘이 필요한 이유를 데이터 무결성과 관련지어 설명해주세요. 동기화가 없다면 발생할 수 있는 문제 3가지 이상을 예시와 함께 설명해주세요.

동기화는 여러 작업(스레드 또는 프로세스)이 공유 자원에 동시에 접근할 때 발생할 수 있는 충돌이나 데이터 무결성 문제를 방지하고, 올바른 순서와 조정을 보장하는 메커니즘이다.

또한 멀티스레드 환경에서는 여러 스레드가 동일한 데이터나 자원에 접근하려고 할 때 데이터 경합(Race Condition)이나 교착 상태(Deadlock)가 발생할 수 있는데, 이를 방지하기 위해 동기화가 필요하다.

- 데이터 무결성 손실
    - 여러 프로세스나 스레드가 동시에 공유 데이터를 수정하면 의도하지 않은 결과가 발생할 수 있다.
        - ex) 은행 계좌 잔고를 갱신하는 두 트랜잭션이 동기화 없이 실행되면, 잔고가 잘못 계산되어 데이터 불일치가 발생한다.
- 데이터 경합(Race Condition)
    - 여러 스레드가 자원에 동시 접근하여 실행 순서에 따라 예측 불가능한 결과를 초래할 수 있다.
        - ex) 다중 사용자 웹 애플리케이션에서 동일한 파일을 업로드하거나 수정할 경우, 동기화가 없으면 데이터가 덮어쓰이거나 손상될 위험이 있다.
- 데드락(Deadlock)
    - 동기화가 잘못 구현되면 스레드 간 자원 점유 순서가 꼬여 무한 대기에 빠질 수 있다.
        - ex) 한 스레드가 A 자원을 점유한 상태에서 B를 기다리고, 다른 스레드가 B를 점유하며 A를 기다릴 경우 시스템이 멈출 수 있다.

### 락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.

락 (lock)은 하나의 스레드(또는 프로세스)가 자원을 점유할 경우 스레드가 해당 자원에 접근하지 못하도록 제어하는 기법으로, 동작 방식은 다음과 같다.

1. 공유 자원이 비활성 상태일 때 어떤 스레드가 공유 자원에 접근하기 위해 락을 요청한다.
2. 락이 성공적으로 점유되면 해당 스레드는 락을 점유한 채 공유 자원에서 작업을 수행한다.
    1. 이때 락이 점유되어 있기 때문에 다른 스레드는 해당 공유 자원에 대한 요청을 시도하지 않고 대기한다.
3. 작업이 완료되고 락이 해제되면 해당 공유 자원은 비활성 상태로 돌아간다.
    1. 이때 다른 스레드가 락을 요청하고, 해당 공유 자원의 접근을 시도할 수 있다.

데이터 무결성은 데이터가 정확하고 완전하며 일관성이 있다는 것을 보장하는 것이며, 원자성은 작업 단위가 더 이상 나뉠 수 없는 하나의 "원자적" 실행 단위로 동작함을 보장하는 개념이다.

원자성이 보장되면 작업이 모두 실행되거나 전혀 실행되지 않으며, 중간에 중단되거나 일부만 실행되는 일은 없다.

락은 다른 스레드의 작업 간섭을 방지하여 특정 작업 단위(critical section)가 중단 없이 완전하게 실행될 수 있도록 보장하기 때문에 원자성을 보장하며, 동시에 데이터 무결성도 보장한다.

### 뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.

세마포어(Semaphore)는 정해진 수의 스레드만 공유 자원에 접근할 수 있도록 제한하는 동기화 기법으로, 스레드 풀과 같이 다중 자원 접근 제어를 위해 사용한다.

뮤텍스(Mutex)는 한 번에 하나의 작업(프로세스/스레드)만 공유 자원에 접근하도록 보장하는 락으로, 계좌 잔액 업데이트 또는 로그 파일 기록과 같이 단일 자원을 보호하기 위해 사용하며, Binary semaphore(the value can range only between 0 and 1)와 유사하게 동작한다.

뮤텍스는 한 번에 오직 하나의 스레드만 임계 영역에 진입하도록 보장하며, 락을 획득한 스레드가 소유권을 갖고, 그 스레드만이 락을 해제할 수 있도록 하지만, 세마포어의 경우에는 반드시 자원을 할당받은 스레드만 해제해야 한다는 제약이 없다는 차이가 있다.

### 조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.

조건 변수(Condition Variable)는 스레드가 특정 조건이 충족될 때까지 대기하거나, 다른 스레드가 신호(Signal)를 보내 대기 중인 스레드를 깨워 실행을 재개하도록 하는 동기화 기법으로, 일반적으로 뮤텍스 락(Mutex Lock)과 함께 동작한다.

스레드가 어떤 공유 자원에 접근하기 위해 뮤텍스 락을 요청했을 때 조건이 충족되지 않으면 wait()를 호출한 후 조건 변수 대기 큐에 대기 상태로 들어간다.

조건이 충족되면 signal()를 받아 깨어나고, 다시 뮤텍스 락을 요청한다.

이때 다른 스레드가 먼저 해당 공유 자원에 접근했다면 뮤텍스 대기 큐로 이동하게 된다.

여기서 조건 변수 대기 큐는 조건 충족 여부만 관리하고, 뮤텍스 락 소유권 관리는 뮤텍스 대기 큐가 담당한다.

이때 뮤텍스 대기 큐는 락이 해제될 때 스레드를 깨울 수 있으므로, "논리적인 조건이 충족되지 않았는데도" 스레드가 깨어나는 문제가 발생할 수 있기 때문에 조건 변수가 필요하다.

조건 변수는 이렇게 특정 조건을 기반으로 대기를 관리하며, 뮤텍스와 함께 사용하여 효율적인 스레드 동기화를 지원한다.

### 뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.

Coffman 조건은 교착상태 발생의 4가지 필요 조건으로, 네 가지 조건이 동시에 만족되어야 교착상태가 발생한다.

1. 상호 배제(Mutual Exclusion): 최소한 하나의 자원이 한 번에 한 스레드만 해당 자원을 사용할 수 있는 상태로 점유되어야 한다.
2. 점유하며 대기(Hold and Wait): 스레드는 최소한 하나의 자원을 점유한 채 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.
3. 비선점(No Preemption): 자원들은 선점할 수 없어야 한다. 즉, 스레드가 한 번 점유한 자원은 다른 스레드에 의해 강제로 빼앗을 수 없다.
4. 순환 대기 (Circular Wait): 두 개 이상의 스레드가 서로가 보유한 자원을 기다리며 순환적인 대기 구조를 형성해야 한다.

교착 상태 예방이란, Coffman 조건(교착상태 발생의 4가지 필요 조건) 중 적어도 하나가 성립되지 않도록 보장하는 방법이다.

자원이 어떻게 요청될 수 있는지를 제한함으로써 Deadlock을 예방한다.

- 장점: 교착 상태가 발생할 수 있는 조건 자체를 미리 제거하므로, 교착 상태 발생 가능성을 원천적으로 차단할 수 있다.
- 단점: 이러한 제약은 종종 프로세스나 스레드의 동시성을 제한하고, 자원 활용도를 낮추어 시스템 전체 성능에 부정적인 영향을 줄 수 있다.

상호 배제(Mutual Exclusion)는 공유 자원의 무결성을 유지하기 위해 반드시 필요하므로, 데드락 예방을 위해 해당 조건 자체를 제거하는 것은 현실적으로 불가능하거나 바람직하지 않다.

따라서 다음의 3가지 방법으로 데드락을 예방할 수 있다.

- 점유와 대기(Hold and Wait) 조건 제거
    - 자원을 이미 보유한 프로세스가 추가 자원을 기다리지 않도록 만들면 교착 상태를 예방할 수 있다.
        - 필요 자원 사전 예측의 어려움, 자원 활용의 비효율성 등의 문제로 인해 실용적이지 않다.
- 비선점(No Preemption) 조건 제거
    - 프로세스가 자원을 점유한 후 다른 프로세스의 요청에 따라 강제로 자원을 회수(preempt)할 수 있도록 만들면 교착 상태를 예방할 수 있다.
        - 자원 할당 후 강제로 자원을 회수하는 방식은 데이터 일관성을 해칠 위험이 있기 때문에 실용적이지 않다.
- 순환 대기(Circular Wait) 조건 제거
    - 모든 자원에 대해 고정된 순서를 정하고, 프로세스가 해당 순서대로만 자원을 요청하도록 강제하도록 만들면 교착 상태를 예방할 수 있다.
        - 기아 현상(Starvation)의 위험이 증가할 수는 있지만, 자원 간 순환적 요청이 발생하지 않아 데드락을 예방할 수 있기 때문에 비교적 실용적이다.

### 낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.

낙관적 락(Optimistic Lock)은 데이터 충돌이 드물다는 가정하에 락 없이 작업을 수행하고, 충돌이 발생하면 롤백을 통해 해결하는 방식으로, 락(Lock)을 사용하지 않는다.

락을 사용하지 않기 때문에 락 기반의 동기화에 비해 성능 오버헤드가 적고, 충돌이 거의 발생하지 않는 환경에서는 성능이 매우 뛰어나다는 장점이 있다.

하지만 데이터 충돌이 발생하면 변경 사항을 롤백하고 재시도해야 하므로 롤백 비용이 발생할 수 있고, 데이터 경합(Race Condition)이 자주 발생하면 충돌을 처리하는 데 시간이 소요되며, 성능이 급격히 저하될 수 있다는 단점이 있다.

이러한 특징 때문에 읽기 작업이 많고 쓰기 작업이 적은 환경에서 적합하다.

### 데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.

데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어를 활용하면 데이터베이스 연결 또는 동시에 실행할 수 있는 작업(스레드)의 수를 효과적으로 제한할 수 있다.

- 데이터베이스 커넥션 풀의 경우
    - 데이터베이스 연결의 개수를 제한하고자 할 때, 세마포어를 사용하여 초기 허용량을 제어할 수 있다.
- 스레드 풀의 경우
    - 스레드 풀에서 동시에 실행되는 작업의 수를 제한하고자 할 때, 세마포어를 사용하여 허용된 작업 수를 제어할 수 있다.

이렇게 세마포어를 활용하면 자원(데이터베이스 연결, 스레드 등)을 동적으로 관리할 수 있으며, 자원을 모두 사용하고 있을 때 추가 요청은 자동으로 대기하게 되어 자원의 최대 사용량을 초과하지 않도록 하여 자원 고갈을 방지할 수 있다.

### JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?

자바스크립트는 싱글 스레드로 동작하는 언어로, 비동기 처리를 통해 효율적으로 작업을 수행할 수 있지만, 비동기 처리 과정에서 동시성 문제가 발생할 수 있다.

자바스크립트에서 비동기 처리는 주로 콜백 함수, 프로미스, 그리고 async/await를 통해 이루어진다.

- 콜백 함수(Callback Function)
    - 비동기 작업이 완료된 후 호출되는 함수로, 비동기 작업의 결과를 처리하는 데 사용된다.
        - 콜백 함수는 중첩이 많아질수록 코드가 복잡해지고 가독성이 떨어지는 단점이 있다.
- 프로미스(Promise)
    - 비동기 작업의 성공 또는 실패를 나타내는 객체로, then()과 catch() 메서드를 통해 비동기 작업의 결과를 처리할 수 있다.
        - 프로미스를 사용하면 콜백 지옥(callback hell)을 피할 수 있고, 코드의 가독성을 높일 수 있다.
- async/await
    - 프로미스를 더욱 간편하게 사용할 수 있게 해주는 문법으로, async 키워드를 함수 앞에 붙이면 해당 함수는 항상 프로미스를 반환하게 되며, await 키워드를 사용하면 프로미스가 해결될 때까지 기다린 후 결과를 반환한다.
        - async/await를 사용하면 비동기 코드를 동기 코드처럼 작성할 수 있어 가독성이 크게 향상된다.

동시성 문제를 해결하기 위해서는 비동기 작업의 순서를 제어하거나 공유 자원에 대한 접근을 조절해야 하며, 자바스크립트에서는 이를 위해 여러 가지 방법을 사용할 수 있다.

1. async/await를 사용하여 비동기 작업을 순차적으로 실행
    - 이렇게 하면 비동기 작업이 순서대로 실행되므로 동시성 문제가 발생하지 않는다.
2. 뮤텍스(Mutex)와 같은 동기화 메커니즘 사용
    - 뮤텍스 등과 같은 동기화 매커니즘을 통해 공유 자원에 대한 접근을 제어할 수 있다.
        - 예제 코드
            
            ```jsx
            class Mutex {
                constructor() {
                    this.queue = [];
                    this.locked = false;
                }
            
                lock() {
                    return new Promise(resolve => {
                        if (this.locked) {
                            this.queue.push(resolve);
                        } else {
                            this.locked = true;
                            resolve();
                        }
                    });
                }
            
                unlock() {
                    if (this.queue.length > 0) {
                        const resolve = this.queue.shift();
                        resolve();
                    } else {
                        this.locked = false;
                    }
                }
            }
            
            const mutex = new Mutex();
            
            async function criticalSection() {
                await mutex.lock();
                // 공유 자원에 접근
                mutex.unlock();
            }
            ```
            
3. 비동기 작업을 큐(queue)에 넣고 순차적으로 처리
    - 이렇게 하면 비동기 작업이 순서대로 실행되므로 동시성 문제가 발생하지 않는다.

### 오늘의 회고
오늘은 이전보다 정리해야 할 키워드의 양이 많아서 오래 걸렸다. 사실 키워드라기보다는 질문의 양이 많았고, 관련 내용이 교재에 있어서 오래 안 걸릴 줄 알았는데, 파고들다 보니 재밌어서 열심히 했던 것 같다. 앞으로도 재밌게, 능동적으로 공부하는 습관을 길러가야겠다.

### 참고 자료 및 링크
- [Operating System Concepts, 10/E](https://os.ecci.ucr.ac.cr/slides/Abraham-Silberschatz-Operating-System-Concepts-10th-2018.pdf)
- [Modern Operating Systems](https://os.ecci.ucr.ac.cr/slides/Andrew-S.-Tanenbaum-Modern-Operating-Systems.pdf)
- [Lock-Free Programming](https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf)
- [The definition of lock-free](https://stackoverflow.com/questions/72415993/the-definition-of-lock-free)
- [What is lock-free multithreaded programming?](https://stackoverflow.com/questions/14011849/what-is-lock-free-multithreaded-programming)
- [Lock-free vs. wait-free concurrency](https://rethinkdb.com/blog/lock-free-vs-wait-free-concurrency)
- [What's a distributed lock and why use it?](https://stackoverflow.com/questions/11999324/whats-a-distributed-lock-and-why-use-it)
- [Distributed Lock 구현 과정](https://channel.io/ko/blog/articles/abc2d95c)
- [임계영역 문제의 해결방법](https://wikidocs.net/231648)
- [데이터 무결성이란 무엇인가요?](https://www.ibm.com/kr-ko/topics/data-integrity)
- [Semaphore](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html)
- [Synchronization With Semaphores](https://docs.oracle.com/cd/E37838_01/html/E61057/sync-11157.html)
- [데이터베이스 커넥션 풀의 이해와 최적화 전략](https://f-lab.kr/insight/understanding-database-connection-pool)
- [자바의 스레드와 스레드 풀 이해하기](https://f-lab.kr/insight/understanding-java-threads-and-thread-pools-20240701)
- [자바스크립트 비동기 처리와 동시성 문제 해결 방법](https://f-lab.kr/insight/javascript-async-concurrency-20240626)
