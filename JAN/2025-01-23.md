# TIL Template

## 날짜: 2025-01-23

### 스크럼
- 학습 목표 : 능동적으로 공부하기

### 개념 정리

- 자바의 컴파일 과정에서 일어나는 일
    - JDK에 포함된 컴파일러(javac)를 통해 `.java` 파일을 바이트 코드로 이루어져 있는 `.class` 파일로 변환한다.
        - javac은 컴파일할 때 매우 엄격한 정적 코드 점검을 통해 오류를 발견하면 컴파일을 중지하고, 개발자에게 경고를 보여준다.
- 자바의 런타임 과정에서 일어나는 일
    - 컴파일 과정을 거쳐 생성된 `.class` 파일을 각 OS별 기계어로 변환한 후에 JVM을 통해 실행한다.

|  | 정의 | 비고 |
| --- | --- | --- |
| JDK | 자바 프로그램을 개발할 때 필요한 모든 도구가 포함된 소프트웨어 개발 키트 | 자바 컴파일러(javac), 디버거(jdb), 아카이브 도구(jar), 그리고 기타 유틸리티가 포함되어 있다. |
| JRE | 자바 프로그램을 실행하기 위한 환경 | JDK 내부에 포함되어 있으며, JRE만 독립적으로도 설치할 수 있다. |
| JVM | 자바 프로그램이 플랫폼에 독립적으로 실행되도록 해주는 가상 머신으로, 자바의 WORA(Write Once, Run Anywhere) 특성을 가능하게 해준다. | JVM의 아키텍처는 3가지 핵심 구성을 두고 있다.<br>• Class Loader : 바이트 코드를 가지고 옴<br>• Runtime Data Area : 메모리에 올리고<br>• Excution Engine : 실행 |
| ClassLoader(JVM) | 자바 프로그램이 실행될 때 필요한 클래스 파일을 메모리로 로드하는 역할을 하는 컴포넌트 | Javac을 통해 컴파일된 바이트 코드를 Runtime Data Area로 적재한다. |
| Runtime Data Area(JVM) | JVM이 프로그램을 실행하기 위해 사용하는 메모리 영역 | 프로그램 실행 중 생성되는 다양한 데이터를 저장하고 관리하는데 사용된다. |
| Heap(Runtime Data Area) | 자바 애플리케이션이 생성한 모든 객체와 배열이 동적으로 저장되는 영역 | 모든 스레드가 공유한다. |
| Stack(Runtime Data Area) | 메서드 호출 시 생성되는 각종 메서드, 지역 변수, 임시 데이터를 관리하는 영역 | 스레드마다 고유하게 존재한다. |
| ethod(Runtime Data Area) | 클래스 정보, static 변수, 변수 정보, 메소드 정보 등이 저장되는 영역 | 추가로 정적 데이터를 저장하고, 상수 풀(문자열 상수, 숫자 상수 등 런타임 상수가 저장되는 공간)이 포함되어 있다.<br>해당 영역에 적재되면 프로그램이 종료될 때까지 유지되며, 할당되는 시점은 클래스가 메모리에 올라갈 때이다. |
| PC Register(Runtime Data Area) | 자바 프로그램에서 현재 실행 중인 명령어의 주소를 가리키는 추성적 레지스터 | 컴퓨터 구조에서 배우는 PC 레지스터는 CPU의 명령어 주소를 가리키는 물리적 레지스터이고, 여기서는 현재 실행중인 명령어의 주소를 가리키는 추성적 레지스터이다.<br>JVM의 PC 레지스터는 컴퓨터 구조에서 나오는 PC 레지스터의 개념을 차용한 소프트웨어적 구현체이다.<br>스레드마다 고유하게 존재한다. |
| Native Method Area(Runtime Data Area) | JVM이 아닌 네이티브 코드를 실행하는 영역으로, 자바가 아닌 다른 언어로 된 메소드(C, C++ 등)을 실행한다. | 메서드 호출 시마다 스택 프레임을 쌓고, 메서드 호출이 끝나면 해당 스택 프레임을 제거하는 방식으로 작동하며, Native Method Stack이라고도 불린다. |
| Execution Engine | 바이트 코드를 실행하는 역할을 담당하는 실행 엔진 | 자바 클래스가 JVM에 로드된 이후에 바이트 코드를 OS에 맞게 기계어로 변환하고, Runtime Data Area에서 필요한 데이터를 가져와 실행한다. |
| JIT 컴파일러(Execution Engine) | 실행 중인 프로그램에서 반복적으로 실행되는 부분을 기계어로 미리 컴파일하는 컴파일러 | Execution Engine은 인터프리터 방식으로 바이트 코드를 실행하는데, JIT 컴파일러가 자주 실행되는 코드를 기계어로 미리 컴파일하여 성능을 최적화한다. |
| Garbage Collector(Execution Engine) | 힙 메모리 영역에서 더 이상 참조되지 않는 객체들을 자동으로 검출하고 제거하는 시스템 | 프로그램에서 어떤 변수나 객체에서도 참조하지 않는 객체를 사용하지 않는 객체로 간주한다.<br>객체 그래프를 탐색하여 참조 관계를 확인하여 어디에서도 참조되지 않는 객체를 식별하고, 해당 객체를 메모리에서 해제하여 힙 메모리 공간을 확보한다. |

### 선택 키워드

- (선택) 자바코드가 JVM에서 실행되는 큰그림 순서대로 정리 해보기
    1. JVM이 OS로부터 메모리를 할당받는다.
        - JVM은 할당받은 메모리를 여러 영역(Method Area, Heap Area, Stack Area, PC Register, Native Method Stack)으로 나눠서 관리한다.
    2. 컴파일러가 소스 코드를 바이트 코드로 변환한다.
        - 컴파일 과정에서 오류가 발견되면 컴파일을 중지하고, 개발자에게 경고를 보여준다.
    3. 클래스 로더가 `.class` 파일들을 JVM으로 로딩한다.
        - 로딩, 링크, 초기화 과정을 거친다.
            - 로딩
                - 바이트 코드 형태인 `.class` 파일을 찾아 메모리에 로드한다.
            - 링크
                - 로딩된 `.class` 파일은 JVM에서 실행할 수 있도록 검증, 준비, 해석 과정을 거쳐 실행될 준비를 마친다.
            - 초기화
                - 클래스 및 정적 코드 블록을 실행한다.
    4. 로딩된 .class 파일들은 Excution Engine에서 실행 및 해석된다.
        - Execution Engine은 인터프리터 방식으로 바이트 코드를 실행하는데, JIT 컴파일러가 자주 실행되는 코드를 기계어로 미리 컴파일하여 성능을 최적화한다.
            - 인터프리터(Interpreter): 바이트 코드를 한 줄씩 실행
            - JIT(Just-In-Time) 실행 중인 애플리케이션의 반복적으로 실행되는 부분을 감지하여, 그 부분만 기계어로 미리 컴파일
    5. 해석된 바이트 코드들은 메모리에 배치가 되어 있고, 수행이 이루어지며 GC(Garbage Collector)가 동작된다.
        - GC는 Young Generation(Eden 영역)이 꽉 찬 경우, 전체 힙 메모리가 부족한 경우, `System.gc()` 또는 `Runtime.getRuntime().gc()` 호출 등의 조건에서 JVM에 의해 자동으로 실행된다.
    
- (선택) 클래스 파일의 상수는 JVM 메모리 안에서 어디에 저장되는가?
    - 메서드 영역의 상수 풀(Constant Pool)에 저장된다.
        - 상수 풀: 문자열 상수, 숫자 상수 등 런타임 상수(Constant)가 저장되는 공간

- (선택) JVM 메모리 관점에서 String a = ""와 String a = new String("")의 차이점
    - String a = “”;
        - JVM의 메서드 영역에 있는 String Pool에 존재하는 빈 문자열 `“”` 객체를 재사용한다.
        - a == “”는 같은 객체를 참조하기 때문에 true이다.
    - String a = new String(””);
        - String Pool을 사용하지 않고, 힙 영역에 새로운 `String` 객체를 생성한다.
        - a == “”는 새로운 객체를 참조하기 때문에 false이다.

- (선택) static 변수는 GC의 대상인가?
    - static 변수는 메서드 영역에 위치하고, 메서드 영역은 클래스가 로드될 때 할당되며 힙 메모리 영역을 관리하는 GC의 대상이 아니다.

### 오늘의 회고
지금까지 하나의 답을 찾기 위한 공부만 했었는데, 이제는 공부를 할 때 스스로 질문의 꼬리의 꼬리를 물며 파고들자. 그렇게 질문을 하다보면 결국에는 나만의 답을 발견할 것이다!
