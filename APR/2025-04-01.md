# TIL Template

## 날짜: 2025-04-01

### 스크럼
- 학습 목표 : 능동적으로 공부하기

---

## 00.1 프로그래밍

### 1. 형상 관리 도구는 왜 사용하고, 어떤 종류가 있는지 설명해 주세요.

형상 관리 도구는 개발 과정에서 소프트웨어의 변경 이력을 추적하고 관리하기 위해 사용되는 도구로, 여러 사람이 한 프로젝트를 작업할 경우 충돌을 방지하고, 작업을 효율적으로 관리할 수 있게 됩니다.

대표적으로 Git과 SVN이 있습니다.

Git은 분산식 버전 관리 시스템으로, 각 사용자의 컴퓨터에 로컬 저장소가 생성되고, 변경 사항은 각 사용자의 컴퓨터에서 커밋되어 원격 저장소에 저장됩니다.

커밋된 변경 사항은 주장 저장소로 업로드하고, 대부분의 관리를 로컬에서 관리하여 속도가 빠르지만,

중앙 집중식 버전 관리 시스템에 비해 복잡하고 작업 내용을 동기화하는 과정에서 충돌일 발생할 수 있습니다.

SVN은 중앙 집중식 버전 관리 시스템으로, 중앙 서버에서 데이터들을 관리합니다.

모든 사용자들이 단 하나의 서버만을 관리하여 동기화 문제가 없고, 관리하기가 쉽지만

하나의 서버를 사용하다 보니 사용자 수와 커밋의 빈도로 인해 서버의 부하가 크고 브랜치와 머지 기능이 분산식 버전 관리 시스템에 비해 복잡합니다.

### Git과 GitHub의 차이점이 무엇인가요?

Git은 버전 관리 시스템으로, 소프트웨어 개발 및 소스 코드 관리에 사용됩니다.

로컬에서 브랜치를 통해 프로젝트의 기록을 관리할 수 있지만,

다른 개발자와 실시간으로 작업을 공유할 수 없다는 단점이 있습니다.

이를 개선하기 위한 호스팅 서비스가 바로 GitHub입니다.

GitHub의 경우 클라우드 기반으로 로컬의 소스 코드를 업로드하여 다른 개발자들과 공유가 가능합니다.

Git의 기본 기능과 더불어 여러 확장 기능을 제공하며, 저장소를 관리합니다.

### 스냅샷(Snapshot)과 체크아웃(Checkout)

스냅샷은 파일이나 디렉터리의 특정 시점의 상태를 의미하며,

체크아웃은 사용자가 서버로부터 특정 버전의 스냅샷을 받아오는 것을 의미합니다.

---

### 2. 컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.

인터프리터 언어는 인터프리터에 의해 한 줄씩 실행되며,

컴파일 언어의 경우 소스 코드 전체를 컴파일러가 한 번에 번역하여 기계어 코드로 변환되어 실행됩니다.

두 언어의 차이점은 컴파일 과정에서 큰 차이가 있습니다.

컴파일 과정이란 컴파일러가 해석하여 기계어 코드로 변환하는 과정이며,

전체 코드를 한 번 번역을 한 후에 실행하도록 합니다.

컴파일 언어는 말 그대로 컴파일 과정이 있는 언어이며,

인터프리터 언어는 이러한 과정이 없습니다.

컴파일 언어는 이러한 과정으로 인해 프로그램의 오류를 실행 전에 발견할 수 있으며,

처음 컴파일 과정 이후에는 해석된 파일로 재실행을 하여 여러 반복적인 실행이 필요할 때 인터프리터 언어보다 빠르게 동작합니다.

또한 컴파일 언어가 기계어에 좀 더 가까운 저수준 언어이기 때문에 인터프리터 언어보다 더 적은 메모리로 동일한 코드를 실행할 수 있습니다.

그러나 운영체제마다 사용하는 기계어가 다르기 때문에 별도의 처리가 필요하며,

규모가 클수록 컴파일 시간이 오래 걸릴 수 있습니다.

그래서 컴파일 과정, 즉 수정이 자주 발생하는 소프트웨어에서는 빠른 개발과 유지보수, 동적인 환경에 유연한 인터프리터 언어가 효율적일 수 있습니다.

인터프리터 언어의 예시로 Python, JavaScript 등이 있으며,

컴파일 언어는 C, Java 등이 있습니다.

### 자바스크립트는 인터프리터 언어인가요?

네, 맞습니다. 하지만 브라우저에서 채택하고 있는 엔진에 따라 확장성을 위해 컴파일을 거치기도 합니다.

### 컴파일과 인터프리터 두 방식을 모두 쓰는 언어가 있나요?

네, 컴파일과 인터프리터 방식을 모두 사용하는 언어를 하이브리드 언어 또는 혼합형 언어라고 부르기도 합니다.

이러한 하이브리드 언어의 예시로 Java가 있습니다.

자바는 컴파일러가 소스 코드를 바이트 코드로 변환합니다.

이렇게 변환된 바이트 코드는 Excution Engine에서 실행 및 해석되는데,

여기서 Execution Engine이 인터프리터 방식으로 바이트 코드를 실행합니다.

### JIT 컴파일러

JIT 컴파일러는 실행 중인 프로그램에서 반복적으로 실행되는 부분을 기계어로 미리 컴파일하는 동적 컴파일러로,

Execution Engine가 인터프리터 방식으로 바이트 코드를 실행할 때 JIT 컴파일러가 자주 실행되는 코드를 기계어로 미리 컴파일하여 성능을 최적화합니다.

---

### 3. 객체 지향 프로그래밍에 대해서 설명해 주세요.

객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것입니다.

객체 지향 프로그래밍은 상속, 캡슐화, 추상화, 다형성의 4가지 특징을 가지고 있습니다.

- 상속: 부모 클래스의 속성과 메서드를 자식 클래스에서 재사용하거나 확장할 수 있도록 하는 것
- 캡슐화: 객체의 필드과 메서드를 하나로 묶고, 실제 구현 내용 일부를 내부에 감추어 은닉하는 것
- 추상화: 집합을 구성하는 개체들을 일반화하여 자세한 구현 정보는 숨기고 일반 인터페이스를 정의하는 것
- 다형성: 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작할 수 있게 하는 것

### 객체 지향 5원칙이란 무엇인가요?

객체 지향 5원칙, SOLID는 유연하고 확장 가능한 소프트웨어를 설계하기 위해 중요한 원칙으로,

단일 책임 원칙(SRP), 개방 폐쇄 원칙(OCP), 리스코프 치환 원칙(LSP), 인터페이스 분리 원칙(ISP), 의존관계 역전 원칙(DIP)이 있습니다.

- SRP: 단일 책임 원칙, 한 클래스는 하나의 책임만 가져야 한다.
- OCP: 개방-폐쇄 원칙, 기존의 코드는 변경하지 않으면서 기능을 추가할 수 있도록 설계해야 한다.
- LSP: 리스코프 치환 원칙, 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- ISP: 인터페이스 분리 원칙, 인터페이스를 클라이언트에 특화되도록 분리시켜야 한다.
- DIP: 의존관계 역전 원칙, 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다.

---

### 4. 라이브러리와 프레임워크의 차이점에 대해 설명해 주세요.

라이브러리는 재사용 가능한 코드의 모음으로, 특정 기능을 수행하기 위해 필요할 때 가져다 쓸 수 있습니다.

프레임워크는 애플리케이션의 전체적인 구조와 흐름을 정의하고, 개발자가 그 안에 필요한 코드를 작성하도록 하는 것입니다.

라이브러리와 프레임워크의 차이점은 제어의 역전(Inversion of Control)에 있습니다.

라이브러리를 사용할 때에는 개발자가 애플리케이션의 흐름을 직접 설정하고, 라이브러리를 호출하지만,

프레임워크를 사용할 때에는 프레임워크가 애플리케이션의 흐름을 설정하고, 개발자가 작성한 코드를 호출합니다.

---

### 5. 디자인 패턴에 대해 설명해 주세요.

디자인 패턴은 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 수 있는 해결책으로,

특정 문제를 해결하는데 적용할 수 있는 재사용 가능한 솔루션의 템플릿이나 청사진을 의미합니다.

디자인 패턴의 주된 장점은 그 재사용성에 있습니다.

디자인 패턴은 유사한 상황이 발생할 때마다 반복해서 사용될 수 있기 때문에 개발자들이 새로운 문제를 맞닥뜨릴 때마다 처음부터 해결책을 찾아야 하는 어려움을 피할 수 있습니다.

이러한 디자인 패턴을 사용함으로써 개발자들은 더 효율적이고 유지 보수가 용이한 코드를 작성할 수 있습니다.

---

### 6. MVC 패턴에 대하여 설명해 주세요.

MVC 패턴은 애플리케이션을 **모델(Model)**, **뷰(View)**, **컨트롤러(Controller)** 세 가지 역할로 분리하여 개발하는 소프트웨어 아키텍처 패턴입니다.

- 모델(Model)은 애플리케이션의 데이터와 비즈니스 로직을 담당합니다.
- 뷰(View)는 사용자에게 정보를 보여주는 역할을 담당하며, 모델로부터 전달받은 데이터를 기반으로 사용자 인터페이스를 구성하고 표시합니다.
- 컨트롤러(Controller)는 사용자 입력(HTTP 요청 등)을 처리하고, 모델과 뷰 사이의 상호 작용을 관리합니다.

MVC 패턴의 주요 장점은 코드의 분리와 재사용성, 그리고 확장성입니다.

각각의 역할을 분리하여 독립적으로 개발하고 재사용할 수 있으며,

새로운 기능의 추가나 기존 기능의 수정이 필요할 때 하나의 구성 요소만을 변경하면 되기 때문에 확장성이 높아집니다.

### MTV 패턴에 대하여 설명해 주세요.

MTV(Model-Template-View) 패턴은 애플리케이션을 **모델(Model)**, **템플릿(Template)**, **뷰(View)** 세 가지 역할로 분리하여 개발하는 소프트웨어 아키텍처 패턴으로, 주로 Django 웹 프레임워크에서 사용됩니다.

MVC 패턴과 유사한 형태로 볼 수 있으며, 애플리케이션의 코드를 쉽게 관리하고 유지 보수할 수 있도록 돕습니다.

- Model은 애플리케이션의 데이터 구조와 관련된 비즈니스 로직을 답당합니다.
    - DB와의 상호작용, 데이터의 검증 및 처리를 포함합니다.
- Template는 사용자에게 보여질 UI를 정의합니다.
    - 주로 HTML과 유사한 문법을 사용하여 데이터를 동적으로 삽입하며, View에서 전달받은 데이터를 기반으로 사용자에게 렌더링됩니다.
- View는 사용자의 요청을 처리하고, 필요한 데이터를 Model로부터 가져와 Template에 전달하는 역할을 합니다.
    - 이는 MVC 패턴의 Controller와 유사한 기능을 수행하며, 사용자의 요청을 기반으로 적절한 응답을 생성합니다.

---

### 7. API rate limiting이란 무엇이며, 주요 목적은 무엇인가요?

API rate limiting은 특정 시간 동안 API에 대한 요청 횟수를 제한하는 것을 의미하며,

이는 주로 클라이언트나 사용자가 API를 과도하게 호출하는 것을 방지하기 위해 사용됩니다.

모든 서버는 처리할 수 있는 요청에 한계가 있기 때문에 갑작스러운 요청의 폭증은 서버의 과부하를 초래하게 됩니다.

이는 서비스의 정상적인 작동을 방해하게 되며, 따라서 API rate limiting의 첫 번째 주요 목적은 서버와 그에 달린 리소스를 이러한 요청의 폭증으로부터 보호하기 위함입니다.

또한 DDoS와 같은 공격을 방지하거나 그 영향을 최소화하는 데 큰 역할을 하며, 클라우드 환경에서의 불필요한 트래픽 때문에 발생하는 추가적인 비용을 방지할 수 있습니다.

API rate limiting은 특정 시간 동안 특정 IP 주소 또는 클라이언트에서 오는 요청의 수를 제한하거나,

토큰 버킷, 리퀘스트 가중치 할당 등의 복잡한 알고리즘을 사용하여 구현할 수 있습니다.

### 다른 서비스나 서버와의 통신에서 Rate limiting을 적용하는 데 있어서 주의점은 무엇인가요?

Rate limiting을 효과적으로 운영하기 위해서는 정책의 명확성, 적절한 응답 전달, 유연한 정책 관리 등을 주의해야 합니다.

먼저 사용자나 개발자가 Rate limiting의 정책을 쉽게 파악하고 준수할 수 있도록 해당 정책을 API 문서에 포함시키는 것이 필요합니다.

재시도에 대한 안내도 중요한데, 사용자나 클라이언트가 언제 다시 요청을 시도해야 하는지 알 수 있도록 Retry-After 헤더를 사용하여 재시도까지의 대기 시간을 전달하는 것이 좋습니다.

적절한 HTTP 상태 코드, 특히 429 Too Many Requests를 사용하여 요청이 Rate limiting에 의해 제한되었음을 명확하게 알려야 합니다.

---

### 8. 애자일 개발 방법론에 대하여 설명해 주세요.

애자일 개발 방법론은 소프트웨어 개발 프로세스를 더 효율적이고 유연하게 만들기 위한 방법론으로,

변화에 빠르게 대응하며, 고객의 요구사항을 지속적으로 수용하고, 높은 품질의 소프트웨어를 신속하게 제공하는 것입니다.

### 애자일 개발 방법론을 적용하기 위하여 사용되는 프로젝트 관리 도구에 대하여 설명해 주세요.

JIRA는 애자일 개발 방법론의 대표적인 도구 중 하나로, 스크럼과 칸반 방식의 보드를 지원합니다.

또한, 이 도구는 작업의 추적, 버그 및 이슈 트래킹과 같은 기능들을 제공하여 프로젝트의 진행 상황을 명확하게 파악할 수 있게 합니다.

---

## 00.2 웹, 브라우저

### 1. 쿠키(Cookies), 세션 스토리지(Session Storage), 로컬 스토리지(Local Storage)의 차이에 대해 설명해 주세요.

쿠키는 웹사이트에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일로, 키와 값의 쌍으로 이루어져 있습니다.

쿠키는 웹 브라우저 단위의 저장소이기 때문에 웹 브라우저 간 공유가 불가능하여 지역성 문제가 발생할 수 있습니다.

세션 스토리지는 웹 브라우저 창을 닫으면 데이터가 삭제되는 웹 브라우저 저장소로,

사용자 세션의 일시적 설정과 같이 단발적이지만 중요한 데이터를 임시 저장해야할 때 사용합니다.

로컬 스토리지는 웹 브라우저 창을 닫아도 데이터가 영구적으로 저장되는 웹 브라우저 저장소로,

사용자가 마지막으로 사용한 로그인 방법을 저장하는 경우와 같이 장기적으로 유지되어야 하는 데이터를 저장해야할 때 사용합니다.

---

### 2. 브라우저의 동작 과정에 대해서 설명해 주세요.

웹 브라우저에 접속하면 DNS 프로토콜을 통해 URL의 IP 주소를 알아냅니다.

IP 주소를 알아낸 뒤 서버와 TCP 3way-handshake를 통해 연결을 설정합니다.

그리고 해당 IP 주소로 HTTP 요청을 보내 서버로부터 HTML 파일을 응답받습니다.

이후 서버가 TCP 패킷으로 데이터를 보내서 데이터의 수신을 확인합니다.

여기서 혼잡 제어 알고리즘을 통해 패킷의 흐름과 확인 응답을 바탕으로 전송 속도를 결정합니다.

이후 브라우저가 수신된 정보를 파싱하여 해당 데이터를 DOM과 CSSOM으로 바꾸는 과정을 거친 뒤에 렌더 트리를 만들어 렌더링됩니다.

---

### 3. 서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이에 대해 설명해 주세요.

서버 사이드 렌더링(SSR)은 서버 측에서 화면을 렌더링하여 클라이언트에 전달하는 방식입니다.

서버에서 필요한 데이터를 모두 가져와 렌더링하게 되기 때문에 초기 로딩 속도가 빠르고,

모든 컨텐츠가 담겨있기 때문에 효율적으로 검색 엔진 최적화가 가능합니다.

그러나 서버에서 페이지를 새로 가져올 때마다 깜빡임 현상이 발생하며,

서버에 지속적인 요청을 보내기 때문에 서버에 과부하가 걸리기 쉽습니다.

또한, 페이지를 가져오는 시간보다 JS 파일을 가져오는 시간이 느리기 때문에 사용자가 사이트를 볼 수 있는 시간(TTV)과 실제로 상호작용이 가능한 시간(TTI)의 공백 시간이 길다는 단점이 있습니다.

반면, 클라이언트 사이드 렌더링(CSR)은 클라이언트 측에서 화면을 렌더링하는 방식입니다.

JS 파일과 함께 어플리케이션에 필요한 로직, 프레임워크, 소스 코드들을 같이 불러오기 때문에 초기 렌더링 속도가 느립니다.

그러나 페이지가 보이면서 상호작용이 가능해지기 때문에 TTV와 TTI의 공백 시간이 없다는 장점이 있습니다.

---

### 4. 웹 브라우저의 렌더에 관해 설명해 주세요.

웹 브라우저에서 렌더링은 CSSOM과 DOM 트리가 렌더 트리로 합성되고 화면에 그려지는 과정입니다.

이 과정에는 세부적인 단계가 있으며, 각각 Style, Layout, Paint, Compositing이라고 합니다.

스타일 과정에선 DOM과 CSSOM을 합쳐 렌더 트리를 만듭니다.

렌더 트리는 화면에 표시할 요소들만 모아 놓은 것으로, 이러한 렌더 트리를 만드는 과정에서 렌더 트리에 포함된 모든 노드에 계산된 스타일이 무엇인지 결정합니다.

이러한 렌더 트리를 기반으로 레이아웃을 실행합니다.

레이아웃은 렌더 트리의 루트를 시작으로 순회하며 렌더 트리에 있는 모든 노드의 형태와 위치를 결정하는 과정입니다.

이후 각 노드를 화면에 페인팅합니다.

이때 브라우저는 빠른 수행을 위해 화면에 그리는 작업은 몇 개의 레이어로 구분하여 진행하는데, 올바른 순서와 정확한 렌더링ㅇ츨 보장하기 위해 합성 단계를 진행합니다.

합성 과정에서 요소 별로 해당하는 레이어가 무엇인지 알기 위해 메인 스레드가 레이아웃 트리를 순회하며 레이어 트리를 생성합니다.

이후 페인트 순서가 결정되면 메인 스레드가 컴포지터 스레드에게 넘기고, 컴포지터 스레드는 각 레이어를 레스터 라이징합니다.

레스터 라이징이란, 문서의 구조, 각 요소의 스타일, 페인트 순서 등의 정보를 스크린의 픽셀로 바꾸는 것입니다.

---

### 5. 웹사이트 성능 최적화 방법에 대해 설명해 주세요.

웹 사이트 성능 최적화 방법은 크게 렌더링과 로딩, 두 가지로 구분하게 됩니다.

렌더링 성능을 최적화한다는 것은 브라우저가 화면에 그려주는 시간을 줄이는 것으로,

불필요한 애니메이션을 제거하고, GPU를 사용하는 CSS 속성을 사용하여 표현하는 것입니다.

로딩 성능을 최적화하기 위해서 초기 화면에 필요한 파일만 다운받거나,

이미지 등의 큰 데이터를 포함하는 경우는 지연시켜 HTML, CSS, JS 파일을 먼저 다운로드 받게 할 수 있습니다.

---

### 6. 브라우저에서 탭 이동 혹은 탭 종료 시에는 세션 스토리지에 어떤 영향을 끼치나요?

세션 스토리지는 키와 값의 쌍으로 이루어진 데이터를 브라우저에 저장합니다.

브라우저의 탭이나 창에 종속되기 때문에 브라우저의 탭이나 창이 닫힐 때까지만 유효하며,

같은 도메인 내에서만 접근할 수 있습니다.

따라서 브라우저에서 다른 도메인으로 탭을 이동하게 되면 세션 스토리지에 저장된 데이터는 접근할 수 없는 상태가 됩니다.

만약, 해당 도메인으로 다시 돌아오게 된다면 세션 스토리지의 데이터를 다시 사용할 수 있습니다.

브라우저의 탭이나 창을 닫는 경우, 세션 스토리지에 저장된 데이터는 삭제됩니다.

만약 다른 탭이나 창에서 같은 도메인을 열게 된다면 새로운 세션 스토리지가 생성되므로, 이전에 저장한 데이터를 사용할 수 없게 됩니다.
